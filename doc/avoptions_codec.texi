@c DO NOT EDIT THIS FILE!
@c It was generated by print_options.

@section Codec AVOptions
@table @option
@item -b[:stream_specifier] @var{integer} (@emph{output,audio,video})
set bitrate (in bits/s)
@item -ab[:stream_specifier] @var{integer} (@emph{output,audio})
set bitrate (in bits/s)
@item -bt[:stream_specifier] @var{integer} (@emph{output,video})
Set video bitrate tolerance (in bits/s). In 1-pass mode, bitrate tolerance specifies how far ratecontrol is willing to deviate from the target average bitrate value. This is not related to minimum/maximum bitrate. Lowering tolerance too much has an adverse effect on quality.
@item -flags[:stream_specifier] @var{flags} (@emph{input/output,audio,video,subtitles})

Possible values:
@table @samp
@item mv4
use four motion vectors per macroblock (MPEG-4)
@item qpel
use 1/4-pel motion compensation
@item loop
use loop filter
@item qscale
use fixed qscale
@item gmc
use gmc
@item mv0
always try a mb with mv=<0,0>
@item input_preserved

@item pass1
use internal 2-pass ratecontrol in first  pass mode
@item pass2
use internal 2-pass ratecontrol in second pass mode
@item gray
only decode/encode grayscale
@item emu_edge
do not draw edges
@item psnr
error[?] variables will be set during encoding
@item truncated

@item naq
normalize adaptive quantization
@item ildct
use interlaced DCT
@item low_delay
force low delay
@item global_header
place global headers in extradata instead of every keyframe
@item bitexact
use only bitexact functions (except (I)DCT)
@item aic
H.263 advanced intra coding / MPEG-4 AC prediction
@item ilme
interlaced motion estimation
@item cgop
closed GOP
@end table
@item -me_method[:stream_specifier] @var{integer} (@emph{output,video})
set motion estimation method

Possible values:
@table @samp
@item zero
zero motion estimation (fastest)
@item full
full motion estimation (slowest)
@item epzs
EPZS motion estimation (default)
@item esa
esa motion estimation (alias for full)
@item tesa
tesa motion estimation
@item dia
diamond motion estimation (alias for EPZS)
@item log
log motion estimation
@item phods
phods motion estimation
@item x1
X1 motion estimation
@item hex
hex motion estimation
@item umh
umh motion estimation
@item iter
iter motion estimation
@end table
@item -extradata_size[:stream_specifier] @var{integer} (@emph{})
@item -time_base[:stream_specifier] @var{rational number} (@emph{})
@item -g[:stream_specifier] @var{integer} (@emph{output,video})
set the group of picture (GOP) size
@item -ar[:stream_specifier] @var{integer} (@emph{input/output,audio})
set audio sampling rate (in Hz)
@item -ac[:stream_specifier] @var{integer} (@emph{input/output,audio})
set number of audio channels
@item -cutoff[:stream_specifier] @var{integer} (@emph{output,audio})
set cutoff bandwidth
@item -frame_size[:stream_specifier] @var{integer} (@emph{output,audio})
@item -frame_number[:stream_specifier] @var{integer} (@emph{})
@item -delay[:stream_specifier] @var{integer} (@emph{})
@item -qcomp[:stream_specifier] @var{float} (@emph{output,video})
video quantizer scale compression (VBR). Constant of ratecontrol equation. Recommended range for default rc_eq: 0.0-1.0
@item -qblur[:stream_specifier] @var{float} (@emph{output,video})
video quantizer scale blur (VBR)
@item -qmin[:stream_specifier] @var{integer} (@emph{output,video})
minimum video quantizer scale (VBR)
@item -qmax[:stream_specifier] @var{integer} (@emph{output,video})
maximum video quantizer scale (VBR)
@item -qdiff[:stream_specifier] @var{integer} (@emph{output,video})
maximum difference between the quantizer scales (VBR)
@item -bf[:stream_specifier] @var{integer} (@emph{output,video})
use 'frames' B frames
@item -b_qfactor[:stream_specifier] @var{float} (@emph{output,video})
QP factor between P- and B-frames
@item -rc_strategy[:stream_specifier] @var{integer} (@emph{output,video})
ratecontrol method
@item -b_strategy[:stream_specifier] @var{integer} (@emph{output,video})
strategy to choose between I/P/B-frames
@item -ps[:stream_specifier] @var{integer} (@emph{output,video})
RTP payload size in bytes
@item -mv_bits[:stream_specifier] @var{integer} (@emph{})
@item -header_bits[:stream_specifier] @var{integer} (@emph{})
@item -i_tex_bits[:stream_specifier] @var{integer} (@emph{})
@item -p_tex_bits[:stream_specifier] @var{integer} (@emph{})
@item -i_count[:stream_specifier] @var{integer} (@emph{})
@item -p_count[:stream_specifier] @var{integer} (@emph{})
@item -skip_count[:stream_specifier] @var{integer} (@emph{})
@item -misc_bits[:stream_specifier] @var{integer} (@emph{})
@item -frame_bits[:stream_specifier] @var{integer} (@emph{})
@item -codec_tag[:stream_specifier] @var{integer} (@emph{})
@item -bug[:stream_specifier] @var{flags} (@emph{input,video})
work around not autodetected encoder bugs

Possible values:
@table @samp
@item autodetect

@item old_msmpeg4
some old lavc-generated MSMPEG4v3 files (no autodetection)
@item xvid_ilace
Xvid interlacing bug (autodetected if FOURCC == XVIX)
@item ump4
(autodetected if FOURCC == UMP4)
@item no_padding
padding bug (autodetected)
@item amv

@item ac_vlc
illegal VLC bug (autodetected per FOURCC)
@item qpel_chroma

@item std_qpel
old standard qpel (autodetected per FOURCC/version)
@item qpel_chroma2

@item direct_blocksize
direct-qpel-blocksize bug (autodetected per FOURCC/version)
@item edge
edge padding bug (autodetected per FOURCC/version)
@item hpel_chroma

@item dc_clip

@item ms
work around various bugs in Microsoft's broken decoders
@item trunc
truncated frames
@end table
@item -strict[:stream_specifier] @var{integer} (@emph{input/output,audio,video})
how strictly to follow the standards

Possible values:
@table @samp
@item very
strictly conform to a older more strict version of the spec or reference software
@item strict
strictly conform to all the things in the spec no matter what the consequences
@item normal

@item unofficial
allow unofficial extensions
@item experimental
allow non-standardized experimental things
@end table
@item -b_qoffset[:stream_specifier] @var{float} (@emph{output,video})
QP offset between P- and B-frames
@item -err_detect[:stream_specifier] @var{flags} (@emph{input,audio,video})
set error detection flags

Possible values:
@table @samp
@item crccheck
verify embedded CRCs
@item bitstream
detect bitstream specification deviations
@item buffer
detect improper bitstream length
@item explode
abort decoding on minor error detection
@item careful
consider things that violate the spec and have not been seen in the wild as errors
@item compliant
consider all spec non compliancies as errors
@item aggressive
consider things that a sane encoder should not do as an error
@end table
@item -has_b_frames[:stream_specifier] @var{integer} (@emph{})
@item -block_align[:stream_specifier] @var{integer} (@emph{})
@item -mpeg_quant[:stream_specifier] @var{integer} (@emph{output,video})
use MPEG quantizers instead of H.263
@item -qsquish[:stream_specifier] @var{float} (@emph{output,video})
how to keep quantizer between qmin and qmax (0 = clip, 1 = use differentiable function)
@item -rc_qmod_amp[:stream_specifier] @var{float} (@emph{output,video})
experimental quantizer modulation
@item -rc_qmod_freq[:stream_specifier] @var{integer} (@emph{output,video})
experimental quantizer modulation
@item -rc_override_count[:stream_specifier] @var{integer} (@emph{})
@item -rc_eq[:stream_specifier] @var{string} (@emph{output,video})
Set rate control equation. When computing the expression, besides the standard functions defined in the section 'Expression Evaluation', the following functions are available: bits2qp(bits), qp2bits(qp). Also the following constants are available: iTex pTex tex mv fCode iCount mcVar var isI isP isB avgQP qComp avgIITex avgPITex avgPPTex avgBPTex avgTex.
@item -maxrate[:stream_specifier] @var{integer} (@emph{output,audio,video})
Set maximum bitrate tolerance (in bits/s). Requires bufsize to be set.
@item -minrate[:stream_specifier] @var{integer} (@emph{output,audio,video})
Set minimum bitrate tolerance (in bits/s). Most useful in setting up a CBR encode. It is of little use otherwise.
@item -bufsize[:stream_specifier] @var{integer} (@emph{output,audio,video})
set ratecontrol buffer size (in bits)
@item -rc_buf_aggressivity[:stream_specifier] @var{float} (@emph{output,video})
currently useless
@item -i_qfactor[:stream_specifier] @var{float} (@emph{output,video})
QP factor between P- and I-frames
@item -i_qoffset[:stream_specifier] @var{float} (@emph{output,video})
QP offset between P- and I-frames
@item -rc_init_cplx[:stream_specifier] @var{float} (@emph{output,video})
initial complexity for 1-pass encoding
@item -dct[:stream_specifier] @var{integer} (@emph{output,video})
DCT algorithm

Possible values:
@table @samp
@item auto
autoselect a good one (default)
@item fastint
fast integer
@item int
accurate integer
@item mmx

@item altivec

@item faan
floating point AAN DCT
@end table
@item -lumi_mask[:stream_specifier] @var{float} (@emph{output,video})
compresses bright areas stronger than medium ones
@item -tcplx_mask[:stream_specifier] @var{float} (@emph{output,video})
temporal complexity masking
@item -scplx_mask[:stream_specifier] @var{float} (@emph{output,video})
spatial complexity masking
@item -p_mask[:stream_specifier] @var{float} (@emph{output,video})
inter masking
@item -dark_mask[:stream_specifier] @var{float} (@emph{output,video})
compresses dark areas stronger than medium ones
@item -idct[:stream_specifier] @var{integer} (@emph{input/output,video})
select IDCT implementation

Possible values:
@table @samp
@item auto

@item int

@item simple

@item simplemmx

@item libmpeg2mmx

@item arm

@item altivec

@item sh4

@item simplearm

@item simplearmv5te

@item simplearmv6

@item simpleneon

@item simplealpha

@item ipp

@item xvidmmx

@item faani
floating point AAN IDCT
@end table
@item -slice_count[:stream_specifier] @var{integer} (@emph{})
@item -ec[:stream_specifier] @var{flags} (@emph{input,video})
set error concealment strategy

Possible values:
@table @samp
@item guess_mvs
iterative motion vector (MV) search (slow)
@item deblock
use strong deblock filter for damaged MBs
@end table
@item -bits_per_coded_sample[:stream_specifier] @var{integer} (@emph{})
@item -pred[:stream_specifier] @var{integer} (@emph{output,video})
prediction method

Possible values:
@table @samp
@item left

@item plane

@item median

@end table
@item -aspect[:stream_specifier] @var{rational number} (@emph{output,video})
sample aspect ratio
@item -debug[:stream_specifier] @var{flags} (@emph{input/output,audio,video,subtitles})
print specific debug info

Possible values:
@table @samp
@item pict
picture info
@item rc
rate control
@item bitstream

@item mb_type
macroblock (MB) type
@item qp
per-block quantization parameter (QP)
@item mv
motion vector
@item dct_coeff

@item skip

@item startcode

@item pts

@item er
error recognition
@item mmco
memory management control operations (H.264)
@item bugs

@item vis_qp
visualize quantization parameter (QP), lower QP are tinted greener
@item vis_mb_type
visualize block types
@item buffers
picture buffer allocations
@item thread_ops
threading operations
@end table
@item -vismv[:stream_specifier] @var{integer} (@emph{input,video})
visualize motion vectors (MVs)

Possible values:
@table @samp
@item pf
forward predicted MVs of P-frames
@item bf
forward predicted MVs of B-frames
@item bb
backward predicted MVs of B-frames
@end table
@item -cmp[:stream_specifier] @var{integer} (@emph{output,video})
full-pel ME compare function

Possible values:
@table @samp
@item sad
sum of absolute differences, fast (default)
@item sse
sum of squared errors
@item satd
sum of absolute Hadamard transformed differences
@item dct
sum of absolute DCT transformed differences
@item psnr
sum of squared quantization errors (avoid, low quality)
@item bit
number of bits needed for the block
@item rd
rate distortion optimal, slow
@item zero
0
@item vsad
sum of absolute vertical differences
@item vsse
sum of squared vertical differences
@item nsse
noise preserving sum of squared differences
@item w53
5/3 wavelet, only used in snow
@item w97
9/7 wavelet, only used in snow
@item dctmax

@item chroma

@end table
@item -subcmp[:stream_specifier] @var{integer} (@emph{output,video})
sub-pel ME compare function

Possible values:
@table @samp
@item sad
sum of absolute differences, fast (default)
@item sse
sum of squared errors
@item satd
sum of absolute Hadamard transformed differences
@item dct
sum of absolute DCT transformed differences
@item psnr
sum of squared quantization errors (avoid, low quality)
@item bit
number of bits needed for the block
@item rd
rate distortion optimal, slow
@item zero
0
@item vsad
sum of absolute vertical differences
@item vsse
sum of squared vertical differences
@item nsse
noise preserving sum of squared differences
@item w53
5/3 wavelet, only used in snow
@item w97
9/7 wavelet, only used in snow
@item dctmax

@item chroma

@end table
@item -mbcmp[:stream_specifier] @var{integer} (@emph{output,video})
macroblock compare function

Possible values:
@table @samp
@item sad
sum of absolute differences, fast (default)
@item sse
sum of squared errors
@item satd
sum of absolute Hadamard transformed differences
@item dct
sum of absolute DCT transformed differences
@item psnr
sum of squared quantization errors (avoid, low quality)
@item bit
number of bits needed for the block
@item rd
rate distortion optimal, slow
@item zero
0
@item vsad
sum of absolute vertical differences
@item vsse
sum of squared vertical differences
@item nsse
noise preserving sum of squared differences
@item w53
5/3 wavelet, only used in snow
@item w97
9/7 wavelet, only used in snow
@item dctmax

@item chroma

@end table
@item -ildctcmp[:stream_specifier] @var{integer} (@emph{output,video})
interlaced DCT compare function

Possible values:
@table @samp
@item sad
sum of absolute differences, fast (default)
@item sse
sum of squared errors
@item satd
sum of absolute Hadamard transformed differences
@item dct
sum of absolute DCT transformed differences
@item psnr
sum of squared quantization errors (avoid, low quality)
@item bit
number of bits needed for the block
@item rd
rate distortion optimal, slow
@item zero
0
@item vsad
sum of absolute vertical differences
@item vsse
sum of squared vertical differences
@item nsse
noise preserving sum of squared differences
@item w53
5/3 wavelet, only used in snow
@item w97
9/7 wavelet, only used in snow
@item dctmax

@item chroma

@end table
@item -dia_size[:stream_specifier] @var{integer} (@emph{output,video})
diamond type & size for motion estimation
@item -last_pred[:stream_specifier] @var{integer} (@emph{output,video})
amount of motion predictors from the previous frame
@item -preme[:stream_specifier] @var{integer} (@emph{output,video})
pre motion estimation
@item -precmp[:stream_specifier] @var{integer} (@emph{output,video})
pre motion estimation compare function

Possible values:
@table @samp
@item sad
sum of absolute differences, fast (default)
@item sse
sum of squared errors
@item satd
sum of absolute Hadamard transformed differences
@item dct
sum of absolute DCT transformed differences
@item psnr
sum of squared quantization errors (avoid, low quality)
@item bit
number of bits needed for the block
@item rd
rate distortion optimal, slow
@item zero
0
@item vsad
sum of absolute vertical differences
@item vsse
sum of squared vertical differences
@item nsse
noise preserving sum of squared differences
@item w53
5/3 wavelet, only used in snow
@item w97
9/7 wavelet, only used in snow
@item dctmax

@item chroma

@end table
@item -pre_dia_size[:stream_specifier] @var{integer} (@emph{output,video})
diamond type & size for motion estimation pre-pass
@item -subq[:stream_specifier] @var{integer} (@emph{output,video})
sub-pel motion estimation quality
@item -dtg_active_format[:stream_specifier] @var{integer} (@emph{})
@item -me_range[:stream_specifier] @var{integer} (@emph{output,video})
limit motion vectors range (1023 for DivX player)
@item -ibias[:stream_specifier] @var{integer} (@emph{output,video})
intra quant bias
@item -pbias[:stream_specifier] @var{integer} (@emph{output,video})
inter quant bias
@item -global_quality[:stream_specifier] @var{integer} (@emph{output,audio,video})
@item -coder[:stream_specifier] @var{integer} (@emph{output,video})

Possible values:
@table @samp
@item vlc
variable length coder / Huffman coder
@item ac
arithmetic coder
@item raw
raw (no encoding)
@item rle
run-length coder
@item deflate
deflate-based coder
@end table
@item -context[:stream_specifier] @var{integer} (@emph{output,video})
context model
@item -slice_flags[:stream_specifier] @var{integer} (@emph{})
@item -xvmc_acceleration[:stream_specifier] @var{integer} (@emph{})
@item -mbd[:stream_specifier] @var{integer} (@emph{output,video})
macroblock decision algorithm (high quality mode)

Possible values:
@table @samp
@item simple
use mbcmp (default)
@item bits
use fewest bits
@item rd
use best rate distortion
@end table
@item -stream_codec_tag[:stream_specifier] @var{integer} (@emph{})
@item -sc_threshold[:stream_specifier] @var{integer} (@emph{output,video})
scene change threshold
@item -lmin[:stream_specifier] @var{integer} (@emph{output,video})
minimum Lagrange factor (VBR)
@item -lmax[:stream_specifier] @var{integer} (@emph{output,video})
maximum Lagrange factor (VBR)
@item -nr[:stream_specifier] @var{integer} (@emph{output,video})
noise reduction
@item -rc_init_occupancy[:stream_specifier] @var{integer} (@emph{output,video})
number of bits which should be loaded into the rc buffer before decoding starts
@item -flags2[:stream_specifier] @var{flags} (@emph{input/output,audio,video})

Possible values:
@table @samp
@item fast
allow non-spec-compliant speedup tricks
@item noout
skip bitstream encoding
@item ignorecrop
ignore cropping information from sps
@item local_header
place global headers at every keyframe instead of in extradata
@item chunks
Frame data might be split into multiple chunks
@item showall
Show all frames before the first keyframe
@end table
@item -error[:stream_specifier] @var{integer} (@emph{output,video})
@item -threads[:stream_specifier] @var{integer} (@emph{input/output,video})

Possible values:
@table @samp
@item auto
autodetect a suitable number of threads to use
@end table
@item -me_threshold[:stream_specifier] @var{integer} (@emph{output,video})
motion estimation threshold
@item -mb_threshold[:stream_specifier] @var{integer} (@emph{output,video})
macroblock threshold
@item -dc[:stream_specifier] @var{integer} (@emph{output,video})
intra_dc_precision
@item -nssew[:stream_specifier] @var{integer} (@emph{output,video})
nsse weight
@item -skip_top[:stream_specifier] @var{integer} (@emph{input,video})
number of macroblock rows at the top which are skipped
@item -skip_bottom[:stream_specifier] @var{integer} (@emph{input,video})
number of macroblock rows at the bottom which are skipped
@item -profile[:stream_specifier] @var{integer} (@emph{output,audio,video})

Possible values:
@table @samp
@item unknown

@item aac_main

@item aac_low

@item aac_ssr

@item aac_ltp

@item aac_he

@item aac_he_v2

@item aac_ld

@item aac_eld

@item dts

@item dts_es

@item dts_96_24

@item dts_hd_hra

@item dts_hd_ma

@end table
@item -level[:stream_specifier] @var{integer} (@emph{output,audio,video})

Possible values:
@table @samp
@item unknown

@end table
@item -lowres[:stream_specifier] @var{integer} (@emph{input,audio,video})
decode at 1= 1/2, 2=1/4, 3=1/8 resolutions
@item -skip_threshold[:stream_specifier] @var{integer} (@emph{output,video})
frame skip threshold
@item -skip_factor[:stream_specifier] @var{integer} (@emph{output,video})
frame skip factor
@item -skip_exp[:stream_specifier] @var{integer} (@emph{output,video})
frame skip exponent
@item -skipcmp[:stream_specifier] @var{integer} (@emph{output,video})
frame skip compare function

Possible values:
@table @samp
@item sad
sum of absolute differences, fast (default)
@item sse
sum of squared errors
@item satd
sum of absolute Hadamard transformed differences
@item dct
sum of absolute DCT transformed differences
@item psnr
sum of squared quantization errors (avoid, low quality)
@item bit
number of bits needed for the block
@item rd
rate distortion optimal, slow
@item zero
0
@item vsad
sum of absolute vertical differences
@item vsse
sum of squared vertical differences
@item nsse
noise preserving sum of squared differences
@item w53
5/3 wavelet, only used in snow
@item w97
9/7 wavelet, only used in snow
@item dctmax

@item chroma

@end table
@item -border_mask[:stream_specifier] @var{float} (@emph{output,video})
increase the quantizer for macroblocks close to borders
@item -mblmin[:stream_specifier] @var{integer} (@emph{output,video})
minimum macroblock Lagrange factor (VBR)
@item -mblmax[:stream_specifier] @var{integer} (@emph{output,video})
maximum macroblock Lagrange factor (VBR)
@item -mepc[:stream_specifier] @var{integer} (@emph{output,video})
motion estimation bitrate penalty compensation (1.0 = 256)
@item -skip_loop_filter[:stream_specifier] @var{integer} (@emph{input,video})

Possible values:
@table @samp
@item none

@item default

@item noref

@item bidir

@item nokey

@item all

@end table
@item -skip_idct[:stream_specifier] @var{integer} (@emph{input,video})

Possible values:
@table @samp
@item none

@item default

@item noref

@item bidir

@item nokey

@item all

@end table
@item -skip_frame[:stream_specifier] @var{integer} (@emph{input,video})

Possible values:
@table @samp
@item none

@item default

@item noref

@item bidir

@item nokey

@item all

@end table
@item -bidir_refine[:stream_specifier] @var{integer} (@emph{output,video})
refine the two motion vectors used in bidirectional macroblocks
@item -brd_scale[:stream_specifier] @var{integer} (@emph{output,video})
downscale frames for dynamic B-frame decision
@item -keyint_min[:stream_specifier] @var{integer} (@emph{output,video})
minimum interval between IDR-frames
@item -refs[:stream_specifier] @var{integer} (@emph{output,video})
reference frames to consider for motion compensation
@item -chromaoffset[:stream_specifier] @var{integer} (@emph{output,video})
chroma QP offset from luma
@item -trellis[:stream_specifier] @var{integer} (@emph{output,audio,video})
rate-distortion optimal quantization
@item -sc_factor[:stream_specifier] @var{integer} (@emph{output,video})
multiplied by qscale for each frame and added to scene_change_score
@item -mv0_threshold[:stream_specifier] @var{integer} (@emph{output,video})
@item -b_sensitivity[:stream_specifier] @var{integer} (@emph{output,video})
adjust sensitivity of b_frame_strategy 1
@item -compression_level[:stream_specifier] @var{integer} (@emph{output,audio,video})
@item -min_prediction_order[:stream_specifier] @var{integer} (@emph{output,audio})
@item -max_prediction_order[:stream_specifier] @var{integer} (@emph{output,audio})
@item -timecode_frame_start[:stream_specifier] @var{integer} (@emph{output,video})
GOP timecode frame start number, in non-drop-frame format
@item -request_channels[:stream_specifier] @var{integer} (@emph{input,audio})
set desired number of audio channels
@item -bits_per_raw_sample[:stream_specifier] @var{integer} (@emph{})
@item -channel_layout[:stream_specifier] @var{integer} (@emph{input/output,audio})

Possible values:
@table @samp
@end table
@item -request_channel_layout[:stream_specifier] @var{integer} (@emph{input,audio})

Possible values:
@table @samp
@end table
@item -rc_max_vbv_use[:stream_specifier] @var{float} (@emph{output,video})
@item -rc_min_vbv_use[:stream_specifier] @var{float} (@emph{output,video})
@item -ticks_per_frame[:stream_specifier] @var{integer} (@emph{input/output,audio,video})
@item -color_primaries[:stream_specifier] @var{integer} (@emph{input/output,video})
@item -color_trc[:stream_specifier] @var{integer} (@emph{input/output,video})
@item -colorspace[:stream_specifier] @var{integer} (@emph{input/output,video})
@item -color_range[:stream_specifier] @var{integer} (@emph{input/output,video})
@item -chroma_sample_location[:stream_specifier] @var{integer} (@emph{input/output,video})
@item -log_level_offset[:stream_specifier] @var{integer} (@emph{})
set the log level offset
@item -slices[:stream_specifier] @var{integer} (@emph{output,video})
number of slices, used in parallelized encoding
@item -thread_type[:stream_specifier] @var{flags} (@emph{input/output,video})
select multithreading type

Possible values:
@table @samp
@item slice

@item frame

@end table
@item -audio_service_type[:stream_specifier] @var{integer} (@emph{output,audio})
audio service type

Possible values:
@table @samp
@item ma
Main Audio Service
@item ef
Effects
@item vi
Visually Impaired
@item hi
Hearing Impaired
@item di
Dialogue
@item co
Commentary
@item em
Emergency
@item vo
Voice Over
@item ka
Karaoke
@end table
@item -request_sample_fmt[:stream_specifier] @var{value} (@emph{input,audio})
sample format audio decoders should prefer

Possible values:
@table @samp
@end table
@item -pkt_timebase[:stream_specifier] @var{rational number} (@emph{})
@item -sub_charenc[:stream_specifier] @var{string} (@emph{input,subtitles})
set input text subtitles character encoding
@item -sub_charenc_mode[:stream_specifier] @var{flags} (@emph{input,subtitles})
set input text subtitles character encoding mode

Possible values:
@table @samp
@item do_nothing

@item auto

@item pre_decoder

@end table
@item -refcounted_frames[:stream_specifier] @var{integer} (@emph{input,audio,video})
@end table
